<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Radar Chart Options — The Character Sheet</title>
<style>
  :root {
    --warm-brown: #8B6F47;
    --deep-slate: #4A5568;
    --charcoal: #2D2D2D;
    --medium-gray: #666666;
    --light-gray: #999999;
    --very-light-gray: #F7F7F5;
    --border-gray: #E2E0DC;
    --white: #FFFFFF;
    --font-serif: Georgia, 'Times New Roman', serif;
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    /* Attribute accent colours (same as main app) */
    --attr-body:        #7B6B8D;
    --attr-mind:        #4A7C8C;
    --attr-spirit:      #8C6B4A;
    --attr-heart:       #8C4A5A;
    --attr-standing:    #6B7A4A;
    --attr-resilience:  #4A6B7A;
    --attr-discipline:  #5A5A6B;
    --attr-joy:         #8C7A4A;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: var(--font-serif);
    background: var(--very-light-gray);
    color: var(--charcoal);
    padding: 40px 20px 80px;
  }
  h1 {
    font-size: 28px;
    text-align: center;
    margin-bottom: 8px;
    color: var(--charcoal);
  }
  .subtitle {
    text-align: center;
    color: var(--medium-gray);
    font-size: 15px;
    margin-bottom: 48px;
    font-style: italic;
  }
  .demos-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
    gap: 40px;
    max-width: 1200px;
    margin: 0 auto;
  }
  .demo-card {
    background: var(--white);
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    overflow: hidden;
  }
  .demo-header {
    padding: 20px 24px 16px;
    border-bottom: 1px solid var(--border-gray);
  }
  .demo-label {
    font-family: var(--font-sans);
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--light-gray);
    margin-bottom: 4px;
  }
  .demo-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--charcoal);
    margin-bottom: 4px;
  }
  .demo-desc {
    font-family: var(--font-sans);
    font-size: 12px;
    color: var(--medium-gray);
    line-height: 1.5;
  }
  .demo-canvas-wrap {
    padding: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: var(--very-light-gray);
  }
  canvas { display: block; }
  .demo-placement {
    padding: 16px 24px 20px;
    border-top: 1px solid var(--border-gray);
  }
  .placement-label {
    font-family: var(--font-sans);
    font-size: 10px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--light-gray);
    margin-bottom: 6px;
  }
  .placement-text {
    font-family: var(--font-sans);
    font-size: 12px;
    color: var(--medium-gray);
    line-height: 1.6;
  }
  .placement-note {
    font-style: italic;
    color: var(--light-gray);
    margin-top: 4px;
  }
</style>
</head>
<body>

<h1>Radar Chart Options</h1>
<p class="subtitle">Three designs for the eight-attribute radar. Same data, different visual language.<br>
Current scores used: Body 14, Mind 12, Spirit 11, Heart 15, Standing 10, Resilience 13, Discipline 9, Joy 16.</p>

<div class="demos-grid">

  <!-- OPTION A: Attribute-coloured polygon with per-vertex dots -->
  <div class="demo-card">
    <div class="demo-header">
      <div class="demo-label">Option A</div>
      <div class="demo-title">Coloured Spokes</div>
      <div class="demo-desc">Each spoke is drawn in its attribute colour. The data polygon uses a radial gradient fill. Vertex dots are coloured per-attribute. Clean axis lines with subtle grid rings.</div>
    </div>
    <div class="demo-canvas-wrap">
      <canvas id="canvas-a" width="380" height="380"></canvas>
    </div>
    <div class="demo-placement">
      <div class="placement-label">Placement suggestion</div>
      <div class="placement-text">Full-width section at the top of the sheet main content, before the attribute cards. At ~380px it reads clearly on desktop and mobile.</div>
      <div class="placement-text placement-note">Best above the score cards — gives an instant overview before the user digs into individual scores.</div>
    </div>
  </div>

  <!-- OPTION B: Filled stacked rings with score colours -->
  <div class="demo-card">
    <div class="demo-header">
      <div class="demo-label">Option B</div>
      <div class="demo-title">Score-Coloured Fill</div>
      <div class="demo-desc">The data polygon is filled with each vertex's score colour blended into a gradient. Axis spokes are neutral. The visual immediately communicates which areas are green vs red.</div>
    </div>
    <div class="demo-canvas-wrap">
      <canvas id="canvas-b" width="380" height="380"></canvas>
    </div>
    <div class="demo-placement">
      <div class="placement-label">Placement suggestion</div>
      <div class="placement-text">In the sidebar alongside the profile — replaces the empty space below the profile photo and action buttons. At ~220px it still reads well on desktop.</div>
      <div class="placement-text placement-note">Good if you want a compact overview in the sidebar rather than interrupting the main content flow.</div>
    </div>
  </div>

  <!-- OPTION C: Minimal outline — no fill, just nodes with score labels -->
  <div class="demo-card">
    <div class="demo-header">
      <div class="demo-label">Option C</div>
      <div class="demo-title">Minimal Node Map</div>
      <div class="demo-desc">No polygon fill. The data points float as coloured circles with the score shown inside. Axis lines are very light. The shape is read through the node positions — elegant and uncluttered.</div>
    </div>
    <div class="demo-canvas-wrap">
      <canvas id="canvas-c" width="380" height="380"></canvas>
    </div>
    <div class="demo-placement">
      <div class="placement-label">Placement suggestion</div>
      <div class="placement-text">Collapsible section in the sheet sidebar (below actions), or as a compact 260px version above the attribute cards — works at many sizes.</div>
      <div class="placement-text placement-note">Good for a less data-dense feel; the score nodes make it easy to read without expanding any card.</div>
    </div>
  </div>

</div>

<script>
// ==================== SHARED DATA ====================
const ATTRS = [
  { key: 'body',        name: 'Body',        score: 14 },
  { key: 'mind',        name: 'Mind',        score: 12 },
  { key: 'spirit',      name: 'Spirit',      score: 11 },
  { key: 'heart',       name: 'Heart',       score: 15 },
  { key: 'standing',    name: 'Standing',    score: 10 },
  { key: 'resilience',  name: 'Resilience',  score: 13 },
  { key: 'discipline',  name: 'Discipline',  score: 9  },
  { key: 'joy',         name: 'Joy',         score: 16 },
];

const ATTR_COLORS = {
  body:       '#7B6B8D',
  mind:       '#4A7C8C',
  spirit:     '#8C6B4A',
  heart:      '#8C4A5A',
  standing:   '#6B7A4A',
  resilience: '#4A6B7A',
  discipline: '#5A5A6B',
  joy:        '#8C7A4A',
};

const SCORE_COLORS = [
  { max: 4,  color: '#DC2626' },
  { max: 7,  color: '#EA580C' },
  { max: 9,  color: '#D97706' },
  { max: 11, color: '#9CA3AF' },
  { max: 13, color: '#65A30D' },
  { max: 15, color: '#16A34A' },
  { max: 17, color: '#059669' },
  { max: 20, color: '#047857' },
];

function getScoreColor(score) {
  for (const tier of SCORE_COLORS) {
    if (score <= tier.max) return tier.color;
  }
  return '#047857';
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

const N = ATTRS.length;
const MAX_SCORE = 20;

function getAngle(i) {
  // Start from top (270°), go clockwise
  return (Math.PI * 2 * i / N) - Math.PI / 2;
}

function polarToXY(cx, cy, r, angle) {
  return [cx + r * Math.cos(angle), cy + r * Math.sin(angle)];
}

// ==================== OPTION A: Coloured Spokes ====================
(function drawOptionA() {
  const canvas = document.getElementById('canvas-a');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2;
  const maxR = 140;
  const labelOffset = 56;

  ctx.clearRect(0, 0, W, H);

  // Grid rings (5 rings at 4, 8, 12, 16, 20)
  const gridScores = [4, 8, 12, 16, 20];
  gridScores.forEach(gs => {
    const r = (gs / MAX_SCORE) * maxR;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Spokes — coloured per attribute
  ATTRS.forEach((attr, i) => {
    const angle = getAngle(i);
    const [x, y] = polarToXY(cx, cy, maxR, angle);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.strokeStyle = hexToRgba(ATTR_COLORS[attr.key], 0.35);
    ctx.lineWidth = 1.5;
    ctx.stroke();
  });

  // Data polygon — build points
  const pts = ATTRS.map((attr, i) => {
    const r = (attr.score / MAX_SCORE) * maxR;
    return polarToXY(cx, cy, r, getAngle(i));
  });

  // Fill with warm semi-transparent gradient from center
  const fillGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
  fillGrad.addColorStop(0, 'rgba(139,111,71,0.18)');
  fillGrad.addColorStop(1, 'rgba(139,111,71,0.05)');
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  pts.forEach(([x, y]) => ctx.lineTo(x, y));
  ctx.closePath();
  ctx.fillStyle = fillGrad;
  ctx.fill();

  // Polygon stroke
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  pts.forEach(([x, y]) => ctx.lineTo(x, y));
  ctx.closePath();
  ctx.strokeStyle = 'rgba(139,111,71,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Vertex dots — coloured per attribute
  pts.forEach(([x, y], i) => {
    const color = ATTR_COLORS[ATTRS[i].key];
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });

  // Labels
  ctx.font = 'bold 11px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ATTRS.forEach((attr, i) => {
    const angle = getAngle(i);
    const [lx, ly] = polarToXY(cx, cy, maxR + labelOffset, angle);
    ctx.fillStyle = ATTR_COLORS[attr.key];
    ctx.fillText(attr.name, lx, ly - 5);
    ctx.fillStyle = '#999';
    ctx.font = '10px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
    ctx.fillText(attr.score, lx, ly + 7);
    ctx.font = 'bold 11px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
  });
})();

// ==================== OPTION B: Score-Coloured Fill ====================
(function drawOptionB() {
  const canvas = document.getElementById('canvas-b');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2;
  const maxR = 140;
  const labelOffset = 56;

  ctx.clearRect(0, 0, W, H);

  // Grid rings
  [4, 8, 12, 16, 20].forEach(gs => {
    const r = (gs / MAX_SCORE) * maxR;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,0,0,0.07)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Grid labels on right axis (12 o'clock spoke)
  ctx.fillStyle = '#bbb';
  ctx.font = '9px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  [5, 10, 15, 20].forEach(gs => {
    const r = (gs / MAX_SCORE) * maxR;
    ctx.fillText(gs, cx + r + 3, cy);
  });

  // Neutral spokes
  ATTRS.forEach((_, i) => {
    const angle = getAngle(i);
    const [x, y] = polarToXY(cx, cy, maxR, angle);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Data polygon
  const pts = ATTRS.map((attr, i) => {
    const r = (attr.score / MAX_SCORE) * maxR;
    return polarToXY(cx, cy, r, getAngle(i));
  });

  // Build a per-vertex coloured fill by drawing triangular slices
  ATTRS.forEach((attr, i) => {
    const next = (i + 1) % N;
    const color = getScoreColor(attr.score);
    const avgScore = (attr.score + ATTRS[next].score) / 2;
    const avgColor = getScoreColor(Math.round(avgScore));

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.lineTo(pts[next][0], pts[next][1]);
    ctx.closePath();

    // Gradient from vertex colour to centre
    const grad = ctx.createLinearGradient(cx, cy, pts[i][0], pts[i][1]);
    grad.addColorStop(0, hexToRgba(color, 0.05));
    grad.addColorStop(1, hexToRgba(color, 0.3));
    ctx.fillStyle = grad;
    ctx.fill();
  });

  // Polygon stroke
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  pts.forEach(([x, y]) => ctx.lineTo(x, y));
  ctx.closePath();
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Vertex dots — score coloured
  pts.forEach(([x, y], i) => {
    const color = getScoreColor(ATTRS[i].score);
    ctx.beginPath();
    ctx.arc(x, y, 7, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2.5;
    ctx.stroke();
  });

  // Labels
  ATTRS.forEach((attr, i) => {
    const angle = getAngle(i);
    const [lx, ly] = polarToXY(cx, cy, maxR + labelOffset, angle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#555';
    ctx.font = 'bold 11px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
    ctx.fillText(attr.name, lx, ly - 5);
    const scoreColor = getScoreColor(attr.score);
    ctx.fillStyle = scoreColor;
    ctx.font = 'bold 12px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
    ctx.fillText(attr.score, lx, ly + 7);
  });
})();

// ==================== OPTION C: Minimal Node Map ====================
(function drawOptionC() {
  const canvas = document.getElementById('canvas-c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cx = W / 2, cy = H / 2;
  const maxR = 140;
  const labelOffset = 52;
  const NODE_R = 16;

  ctx.clearRect(0, 0, W, H);

  // Very subtle grid
  [5, 10, 15, 20].forEach(gs => {
    const r = (gs / MAX_SCORE) * maxR;
    ctx.beginPath();
    // Draw octagon for grid at this radius
    for (let i = 0; i < N; i++) {
      const [x, y] = polarToXY(cx, cy, r, getAngle(i));
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = 'rgba(0,0,0,0.05)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Spokes — very light
  ATTRS.forEach((_, i) => {
    const angle = getAngle(i);
    const [x, y] = polarToXY(cx, cy, maxR + 4, angle);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Connection lines between adjacent nodes
  const pts = ATTRS.map((attr, i) => {
    const r = (attr.score / MAX_SCORE) * maxR;
    return polarToXY(cx, cy, r, getAngle(i));
  });

  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  pts.forEach(([x, y]) => ctx.lineTo(x, y));
  ctx.closePath();
  ctx.strokeStyle = 'rgba(100,100,100,0.15)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([3, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Node circles — score coloured with score text inside
  pts.forEach(([x, y], i) => {
    const color = getScoreColor(ATTRS[i].score);
    // Outer halo
    ctx.beginPath();
    ctx.arc(x, y, NODE_R + 4, 0, Math.PI * 2);
    ctx.fillStyle = hexToRgba(color, 0.12);
    ctx.fill();
    // Main circle
    ctx.beginPath();
    ctx.arc(x, y, NODE_R, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2.5;
    ctx.stroke();
    // Score text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ATTRS[i].score, x, y);
  });

  // Attribute labels — outside nodes
  ATTRS.forEach((attr, i) => {
    const angle = getAngle(i);
    const [lx, ly] = polarToXY(cx, cy, maxR + labelOffset, angle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#666';
    ctx.font = '11px -apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif';
    ctx.fillText(attr.name, lx, ly);
  });
})();
</script>
</body>
</html>
